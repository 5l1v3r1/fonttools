<?xml version="1.0" encoding="utf-8"?>


<xml>

	<synopsis description="" keywords="" generate="0" name="RoboThon 2006" />


		<h1>
		Font &amp; Info objects
		</h1>
		<img src="http://letterror.com/code/robofab/img/offdrawmodel_07.gif" width="140" height="96" />


		<h2>
			Code!
		</h2>
		<p>
			So now then, you should have your editor fired up. Your RoboFab installed. Locate the 
			<strong>
				output
			</strong>
			window as well. 
		</p>
		<python><![CDATA[import robofab.world]]></python>
		<p>
			If that runs without problems you're good to go. If a new window pops up with a <strong>traceback</strong> like this it means there's something wrong with the installation.
		</p>
		
<python type="output"><![CDATA[Traceback (most recent call last):
File "<string>", line 1, in ?
ImportError: No module named robofab.world]]></python>


<p>
In this documentation, stuff in the output window is indicated with a tinted background. Whenever something is printed in Python code it will end up in the output window.
</p>

			<h2>
				Huh, import ?
			</h2>
			<p>
				Python can do a lot of different things. Some of its functionality is always available (the 
				<strong>
					built-in
				</strong>
				things) but most of it is stored in seperate 
				<strong>
					modules</strong>. When you want to use code from a different module, you need to 
				<strong>
					import
				</strong>
				it first so that Python knows it needs to look somewhere else for objects, functions and stuff. Most of the Robofab stuff is stored in the 
				<strong>
					robofab.world
				</strong>
				module. Notice that dot there? The dot syntax also works for modules and modules within modules. If you want to import a module and Python can't find it, you will get a traceback with an <strong>ImportError</strong>. You can also import specific things from another module, then you write:
			</p>
<python><![CDATA[from someModule import oneSpecificThing
from someModule.subModule import oneSpecificThing
from someModule import anotherSpecificThing, andAnotherThing

# and these:
import someModule
import someModule.subModule
]]></python>
			
			
			
			<h2>CurrentFont()</h2>
			<p>
So, suppose you have FontLab, and a font file open. Make sure it is a font you can trash if you have to, and not the single copy of the production master of your newest bestseller. How do you get started talking to that font in Python? Use <strong>CurrentFont()</strong>. This is a special function which will return an object for the font which is at the front. When there are no fonts it will return <strong>None</strong>.
			</p>


<python><![CDATA[from robofab.world import CurrentFont
print CurrentFont()]]></python>

<python type="output"><![CDATA[<RFont font for DemoFont Italic>]]></python>
			
<p>
A <a href="http://letterror.com/code/robofab/objects/font.html" target="new" class="reference">Font</a> object! We'll be using CurrentFont and that font object shortly, but first let's have a look at CurrentFont's siblings: <strong>CurrentGlyph</strong> and <strong>AllFonts</strong>.
</p>

<python><![CDATA[# open a glyph in FL first!
from robofab.world import CurrentGlyph
print CurrentGlyph()]]></python>

<python type="output"><![CDATA[<RGlyph for DemoFont.ograve>]]></python>
			
<p>
<strong>CurrentGlyph()</strong> returns a <a href="http://letterror.com/code/robofab/objects/glyph.html" target="new" class="reference">Glyph</a> object for the glyph which is at the front. So this is a useful place to start if you want to write a script which manipulates a single glyph and you want an object for that glyph.
</p>


<python><![CDATA[# open a couple of fonts in FL first!
from robofab.world import AllFonts
print AllFonts()]]></python>

<python type="output"><![CDATA[[<RFont font for MyDemoFont>,
<RFont font for AnotherFont Plain>,
<RFont font for AnotherFont Italic>]
]]></python>
			
<p>
<strong>AllFonts()</strong> returns a list with Font objects, one object for each open font. CurrentFont, CurrentGlyph and AllFonts are three very useful functions, and they all live in the robofab.world module. We'll be using them a  lot.
</p>



<h2>Some Font attributes</h2>
<p>
So what are attributes of fonts objects? Let's have a look (at the documentation!).
</p>


<python><![CDATA[# open a couple of fonts in FL first!
from robofab.world import CurrentFont
font = CurrentFont()
print font.path
print font.kerning
print font.info]]></python>

<python type="output"><![CDATA[/aFolder/anotherFolder/demoStuff/myFont.vfb
<RKerning for MyFont Plain>
<RInfo for MyFont Plain>]]></python>

<p>
Hang on! that didn't print anything that looks like kerning, and what's that font.info thing? Remember that objects can contain objects? The object model splits all font related data into smaller, easier to manage pieces. So a <strong>Font</strong> object has one single <strong>Info</strong> object which in turn stores all of the naming and dimensions. Same for font.kerning, it's an object which represents all kerning data of the font. We'll get back to the <a href="http://letterror.com/code/robofab/objects/kerning.html" target="new" class="reference">kerning object</a> later.
</p>

<h2>Some Info attributes</h2>

<p>
The <strong>Info</strong> object stores all of the <a href="http://letterror.com/code/robofab/objects/info.html" target="new" class="reference">font's names, key dimensions</a> etc. 
</p>

<pythonsource src="examples/someFontInfoAttributes.py"/>

<python type="output"><![CDATA[MyDemo
Plain
MyDemo Plain
1000
720
-280]]></python>

<p>
Almost all attributes can also be set to new values. This is when it starts getting interesting. But it also opens new ways of messing your font up.
</p>


<pythonsource src="examples/someFontInfoAttributes2.py"/>

<python type="output"><![CDATA[MyFamily
Roman
MyFamily-Roman
600
-400
]]></python>

<p>
A useful method of the Info object is <strong>autoNaming()</strong>. It assumes you have entered correct data for <strong>familyName</strong> and <strong>styleName</strong>. Based on these 2 values, a bunch of variations and permutations are generated and stored in the appropriate fields. These are the basic names, no fancy OpenType stuff.
</p>

<pythonsource src="examples/infoAutonaming.py"/>

<python type="output">myFamilyName myStyleName
myFamilyName-myStyleName
myFamilyName</python>

<h2>Getting to glyphs</h2>
<p>
We've seen <strong>CurrentGlyph</strong> and <strong>CurrentFont</strong>, but how do you we get to other glyphs in a font? A <strong>Font</strong> object contains glyphs and this is what you do to get to them:
</p>

<pythonsource src="examples/getSomeGlyphs.py"/>

<python type="output"><![CDATA[<RGlyph for MyFamily-Roman.A>
<RGlyph for MyFamily-Roman.Adieresis>
<RGlyph for MyFamily-Roman.two>
<RGlyph for MyFamily-Roman.afii12934>
]]></python>

<p>
The Font object in this case behaves like a Python dictionary object. Between the <strong>[</strong> square brackets <strong>]</strong>  you can ask for a glyph by its (postscript) name. In Python speak: 
</p>

<python><![CDATA[value = dictionary[key]
]]></python>


<p>
If you want to look at all glyphs in a font, one at a time, you can <strong>loop</strong> or <strong>iterate</strong> through the font. It's written like this:
</p>



<pythonsource src="examples/iterateFont.py"/>

<python type="output"><![CDATA[font has 201 glyphs
<RGlyph for MyFamily-Roman.aring>
<RGlyph for MyFamily-Roman.ordfeminine>
<RGlyph for MyFamily-Roman.less>
<RGlyph for MyFamily-Roman.ograve>
<RGlyph for MyFamily-Roman.V>
<RGlyph for MyFamily-Roman.dollar>
<RGlyph for MyFamily-Roman.circumflex>
..etc..]]></python>

<p>
A couple of things to look for in the example above: 
<ul>
<li><strong>len(font)</strong> shows Python's built-in <strong>len()</strong> function, which will try to count the thing its given and it will return the number. Fonts like to be counted and they respond with the number of glyphs. In this case the font has 201 glyphs.</li>

<li>
All the glyphs are mixed up! there is no particular order! chaos! In Python dictionaries there is no standard order in which the keys appear. It will iterate through all the glyphs though. 
</li>

<li>Notice the indentation at the beginning of the line under <strong>for glyph in font:</strong> This is Python's way of showing that all of the code that's indented belongs to the same loop. When the code is <strong>dedented</strong> again that's where Python will continue when it is done with the loop.
</li>

</ul>
</p>


<p>
When  you want to be sure about the order in which the glyphs are looked at, you need to sort them first. Example:
</p>

<python><![CDATA[# iteration through alphabetically sorted glyphnames
from robofab.world import CurrentFont

font = CurrentFont()
print "font has %d glyphs" % len(font)

# names is now a list of strings, the names of the glyphs
# not the glyphs themselves!
names = font.keys()

# the list of names is sorted
names.sort()

# now we iterate through the list of names
for glyphName in names:
	# now we ask for the glyph with glyphName
	print font[glyphName]
]]></python>

<python type="output"><![CDATA[font has 201 glyphs
<RGlyph for MyFamily-Roman.A>
<RGlyph for MyFamily-Roman.AE>
<RGlyph for MyFamily-Roman.Aacute>
<RGlyph for MyFamily-Roman.Acircumflex>
<RGlyph for MyFamily-Roman.Adieresis>
<RGlyph for MyFamily-Roman.Agrave>
<RGlyph for MyFamily-Roman.Aring>
<RGlyph for MyFamily-Roman.Atilde>
<RGlyph for MyFamily-Roman.B>
..etc..]]></python>
			
			
</xml>