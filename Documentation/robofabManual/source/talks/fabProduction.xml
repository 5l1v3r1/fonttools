<?xml version="1.0" encoding="utf-8"?>


<xml>

	<synopsis description="" keywords="" generate="0" name="RoboThon 2006" />


		<h1>
			Scripting for production
		</h1>
		
		
		<img src="http://letterror.com/code/robofab/img/ondrawmodel_07.gif"/>
		
	
	<h2>Production</h2>
	<p>

In the production phase of a font it all comes together: moving stuff around, naming, interpolations, quality control, generating, database work, it pays to invest some time (or money) in some really good scripts. Each foundry and designer has their own preferred ways of doing things. It's impossible to describe one production process and please everyone. So instead we're going to look at some of the things you probably have to do anyway. You will have to match and adapt for your own methods.
	</p>
	<p>
	Production scripts can save a lot of time. But be careful: it is costly to  make mistakes with your production sources. Make sure to <strong>test</strong> production scripts first on duplicate data, preferably in a different folder. Doing something "quickly" to a massive kerning table only to discover it was your only copy, and the action was wrong — will not save you any time. Like carpentry: measure twice, cut once.
	</p>
	


	<h2>Batch processing</h2>
	<p>
Here are some examples of applying changes to several fonts at once using <strong>AllFonts()</strong>. Keep in mind that this applies to all fonts you have open in FontLab. So make sure to close any fonts that you don't want treated this way before running the script.
	</p>

<pythonsource src="examples/allFontsFontInfo.py"/>

<p>
Obviously you can extend these to do lots more.
</p>

	<pythonsource src="examples/makeFontInfoReport.py"/>


<p>
This is a more complex script. It iterates through all open fonts, collects some data in each and finally asks for a place to save all the data in a text file.
</p>

	<pythonsource src="examples/batchSaveAs.py"/>


<p>
This asks for a folder, then proceeds to save all open fonts in this folder.
</p>





	<pythonsource src="examples/batchInterpolate.py"/>

<p>
Here you can pick two fonts from the open fonts. The script will create a new, third font, and make interpolations with the interpolation factors in the <strong>values = [.3, .6]</strong> list. The interpolated font is then saved in the same folder as the first master.
</p>

<p>
This touches on a slippery problem which can cause a  lot of confusion. Robofab can only tell FontLab fonts apart from their path attribute, the place where each font is saved. A newly created font has not been saved yet, so it has no path. The effect is that when you have more than one new, unsaved font open, Robofab can't tell them apart (for a couple of reasons) and will continue to work with the first one. It will look like nothing is happening when you run a script. The way around this is to make sure you save each font you created with a script before creating another one. This is safer anyway.
</p>

	<p>Here are some useful bits for batch processing fonts which are not open, but in a file. This script is a way to make python collect all files of a particular kind in a folder or folders within that folder. You can use the walker function outside of this script too, it's a useful thing to know.
	</p>

<pythonsource src="examples/fileWalker.py"/>

<python type="output"><![CDATA[['/Applications/FontLab/Samples/FREESANS.VFB',
'/Applications/FontLab/Samples/FREESERF.VFB']
]]></python>




	
	<h2>Moving stuff around</h2>

	<p>
The moving, merging and splitting of fonts. The first example moves selected glyphs in the same font and renames them. Note that if you remove the line <strong>f.removeGlyph(g.name)</strong> the same script effectively <strong>copies</strong> the glyphs. Also new in this script: it iterates through the whole font and checks for each glyph if the <strong>g.selected</strong> attribute is 1 or 0. If it is 0, the glyph is not selected in the font window. If it is 1, is <strong>is</strong> selected. It then proceeds to create a new glyph name, and calls <strong>f.insertGlyph()</strong> method which takes a glyph as parameter. The optional parameter <strong>as</strong> is to be able to insert the glyph under a different name. If you don't pass a parameter for <strong>as</strong>, the font will insert the glyph under its own name. The glyph can come from the same font, or a different font, or be an orphan glyph.
	</p>


<python><![CDATA[# rename the selected glyphs
# in the current font to <glyphname>.sc

from robofab.world import CurrentFont
f = CurrentFont()

for g in f:
	if g.selected == 0:
		continue
	newName = g.name+".sc"
	print "moving", g.name, "to", newName
	f.insertGlyph(g, as=newName)
	f.removeGlyph(g.name)
	f.update()
]]></python>

<python type="output"><![CDATA[moving A to A.sc
moving C to C.sc
moving B to B.sc]]></python>




	<h2>Generating font binaries</h2>
	<p>
	</p>

	<pythonsource src="examples/batchGenerate.py"/>


<p>
This will generate CFF flavored OpenType fonts for all open files.
</p>


	<pythonsource src="examples/robustBatchGenerate.py"/>


<p>
The script above generates fonts too, but is a bit more robust. FontLab sometimes crashes when it has to generate a long list of fonts and they're all open at the same time. This script asks you for a folder of .vfb sources (which in itself can be a useful ingredient for your own scripts). Then it will open them one by one and generate the fonts in the flavor indicated in the line <strong>f.generate('mactype1', dstDir)</strong>. A list of types and their names can be found in the robofab documentation how-to page on <a href="http://letterror.com/code/robofab/howto/generatefonts.html" class="reference" target="docs">generating fonts.</a> This script also creates a new folder to store the generated fonts in, sorted by type.
</p>










<h2>Merging</h2>

<p>
Here's an script, quite complex, for combining two fonts into one. Maybe not for the newbie, but if you're into it try to figure out how it works. It uses a couple of new concepts, like <strong>Sets</strong> and <strong>DigestPens</strong>. If it is too complicated: don't worry.
</p>

	<pythonsource src="examples/mergeTwoFonts.py"/>

<p>
</p>

<!--

<h2>OpenType NameTable</h2>
<p>
The OpenType nametable contains a lot of names, values, copyright information and tons of other things. For different platforms and in different languages. RoboFab has module (<strong>robofab.tools.nameTable</strong>) which allows direct editing of the nametable data in a FontLab font. Unfortunately in FontLab 4.x the python implementation of this object was broken. So you can't get to the fields with Python and you have to do it all manually in the FontInfo dialog. In FontLab 4.x  nameTable.py will warn you:</p>

<python type="output"><![CDATA[robofab:Lib:robofab:tools:nameTable.py:2: Warning: FontLab contains a bug that renders nameTable.py inoperable]]>
</python>


<p>
It seems fixed in FontLab Studio 5. The information which RoboFab inserts can be retrieved and seen in the Font Info dialog.
</p>

	<pythonsource src="examples/editNameTable.py"/>


<python type="output"><![CDATA[Copyright 2006 RoboFab
[(3, 1, 1033, 'Copyright 2006 RoboFab'),
(1, 0, 0, 'You Mac-Roman-English folks
should know that this is Copyright 2004 RoboFab.')]
]]></python>


	<pythonsource src="examples/someNameTableAttrs.py"/>



-->


<h2>Dealing with Robofab limitations</h2>
<p>
A handful of FontLab's own glyph and font methods are not supported in RoboFab. The reasons for this vary, some of them are very FontLab specific (for instance <strong>fl.productnumber</strong> or <strong>fl.username</strong>), but most of the missing stuff was just not needed very often — the following examples show how to get access to all functionality and attributes in the FontLab layer.

</p>

<h3>FontLab layer</h3>
<p>
To get to the FontLab layer, Robofab's Font and Glyph objects have a <strong>naked()</strong> method which returns the FontLab object. Note that you can still use the Robofab functionality like CurrentFont, CurrentGlyph, pens etc. The FontLab layer <a href="http://dev.fontlab.net/flpydoc/view_html.html" class="reference" target="new">is documented here.</a> Maybe you remember the <strong>naked()</strong> method from the cookie cutter example.
</p>

<python><![CDATA[# show the objects from the fontlab layer
from robofab.world import CurrentFont
f = CurrentFont()
print f.naked()

g =  f["A"]
print g.naked()

]]></python>

<python type="output"><![CDATA[<Font: 'MyFont'>
<Glyph: 'A', 0 nodes, parent: 'MyFont'>
]]></python>


<p>
Other things you need to dig deeper for. Note that some of these objects appear to be broken.


<ul>
	<li>
		<strong>PostScript hints</strong>: the vertical and horizontal hint zones as well as blue values can be read and set.

		<python><![CDATA[# show vhints for current glyph
g = CurrentGlyph()
g.naked().vhints

]]></python>

<python type="output"><![CDATA[[<VHint: p=25, w=163, parent: "a">,<VHint: p=42, w=146, parent: "a">]
]]></python>

	</li>

	<li>
		<strong>All name fields</strong>: the FontLab table of OpenType names, the naming record, is available. See also the <a href="http://dev.fontlab.net/flpydoc/html/NameRecord.xml.html" class="reference" target="new">the FontLab reference for NameRecord</a>






	<pythonsource src="examples/showNamingRecords.py"/>

<python type="output"><![CDATA[256 1 0 0 Bold
256 3 1 1033 Bold]]></python>



	
	
	
	</li>


	<li>
		<strong>Encodings</strong>.The FontLab Encoding object. See also the
		
		<a href="http://dev.fontlab.net/flpydoc/html/Encoding.xml.html" class="reference" target="new">the FontLab reference for Encoding</a>		
		
	
	
<pythonsource src="examples/showEncoding.py"/>

<python type="output"><![CDATA[ <Encoding: parent: "MyDemoRegular">
...
<EncodingRecord: "eacute", unicode: 233> eacute 233
<EncodingRecord: "ecircumflex", unicode: 234> ecircumflex 234
<EncodingRecord: "edieresis", unicode: 235> edieresis 235
<EncodingRecord: "igrave", unicode: 236> igrave 236
<EncodingRecord: "iacute", unicode: 237> iacute 237
<EncodingRecord: "icircumflex", unicode: 238> icircumflex 238
..etc..

]]></python>



	
		
	


	</li>


</ul>

</p>


</xml>