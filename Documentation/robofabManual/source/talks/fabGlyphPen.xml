<?xml version="1.0" encoding="utf-8"?>


<xml>

	<synopsis description="" keywords="" generate="0" name="RoboThon 2006" />



<h1>
			Glyph, Contour &amp; Pen
		</h1>
		
		
				<img src="http://letterror.com/code/robofab/img/ondrawmodel_17.gif" width="140" height="96"/>


		<p>
			
Working with <a href="http://letterror.com/code/robofab/objects/glyph.html" target="new" class="reference">Glyph</a>, <a href="http://letterror.com/code/robofab/objects/contour.html" target="new" class="reference">Contour</a>, <a href="http://letterror.com/code/robofab/howto/usepens.html" target="new" class="reference">Pen</a> objects. Deep in the font live the glyphs. Inside the glyphs are contours, components. Inside a contour are segments and points!
		</p>
	

<p>Previous: <a href="talks/robofab_session1.html">fonts</a>, next: <a href="talks/robofab_session3.html">kerning and metrics, building glyphs</a>
</p>

<h2>Some Glyph attributes</h2>
<p>
In the previous talk we saw ways of getting fonts and glyph objects. Now we're going to see what Glyph objects can do for us. Glyphs are perhaps the most interesting object in the whole API. Some basic attributes of a glyph object:
</p>



<pythonsource src="examples/someGlyphAttributes.py"/>

<python type="output"><![CDATA[A
812
0
0
(0, 0, 812, 600)
65]]></python>

<p>Some of these attributes can also be set, you can put new values in them. Why not all of them? For instance, the bounding box of a glyph is an attribute, it is useful information. But it depends entirely on the size of the contours in the glyph. There's no way in which you could set this attribute other than by changing the actual paths. Useful attributes you <strong>can</strong> set are things like the width, left and right margin:
</p>


<pythonsource src="examples/someGlyphAttributes2.py"/>

<python type="output"><![CDATA[
200
50
50
666]]></python>


<p>
Notice the <strong>glyph.update()</strong> statement at the end. After setting the attributes to new values, the glyph data will be changed. But the FontLab interface will not have noticed your changes. For instance, the little preview in the font window might still show the old version. The <strong>update()</strong> method of the glyph object is a wakeup call for the application to refresh all glyph drawings with the new data. Note that it is just the <strong>representation</strong> that's being updated. The data itself was changed when the script was executed. Saving the file and opening it again will have the same effect in this respect.
</p>

<p>
Have a look at the RoboFab documentation on the <a href="http://letterror.com/code/robofab/objects/glyph.html" target="new" class="reference">Glyph</a> object for more attributes and methods.
</p>


<h2>Some Glyph methods</h2>

<p>


</p>



<pythonsource src="examples/transformGlyph.py"/>


<p>
Note: these will really screw up your glyph if you don't want it to be moved 100 units horizontally and 75 units vertically, then scaled 50% horizontally and 150% vertically. Then the glyph <strong>B</strong> is added, the overlap is removed, the path directions are corrected and finally the app is told something was changed.
</p>

<h2>getParent()</h2>
<p>
The Glyph object has a <strong>glyph.getParent()</strong> method. When called it will return the <strong>Font</strong> object the glyph belongs to. If it has one: "orphan" glyphs are objects which don't belong to any particular font like the result of a <strong>GlyphMath</strong> operation or glyph level interpolation. When there is no parent, <strong>getParent()</strong> returns <strong>None</strong>. You need to test for this result.
</p>

<pythonsource src="examples/aGlyphParent.py"/>

<python type="output"><![CDATA[<RFont font for SomeFont>]]></python>



<h2>The stuff glyphs are made of</h2>

<p>
A glyph consists of contours, which in turn consist of points, right? If only it were that easy. There are all sorts of points conspiring to become all sorts of shapes. Bezier curves, Quadratic curves, open, closed, components. Sometimes it is just the point of view that's different. The <a href="http://letterror.com/code/robofab/howto/understandcontours.html" target="docs"  class="reference">Understanding Contours and Segments</a> section of the RoboFab documentation has a couple of diagrams of the different ways of looking at the vectors in a glyph. Let's have a look at <a href="http://letterror.com/code/robofab/objects/contour.html" target="new" class="reference">Contour</a> objects first.
</p>

<pythonsource src="examples/iterateGlyph.py"/>

<python type="output"><![CDATA[glyph has 2 contours
<RContour for MyDemo Italic.A[0]>
<RContour for MyDemo Italic.A[1]>]]></python>

<p>So a <strong>Glyph</strong> object contains zero, one or more <strong>Contour</strong> objects. Let's see what secrets a Contour has:
</p>



<pythonsource src="examples/iterateContour.py"/>

<python type="output"><![CDATA[
[<RPoint for Plinc01 Plinc01.A[0][0]>,
<RPoint for Plinc01 Plinc01.A[0][1]>,
...
<RPoint for Plinc01 Plinc01.A[0][4]>]

[<RSegment for Plinc01 Plinc01.A[0][0]>,
<RSegment for Plinc01 Plinc01.A[0][1]>,
...
<RSegment for Plinc01 Plinc01.A[0][4]>]

[<RBPoint for unnamed_font.unnamed_glyph[7][0][0]>,
<RBPoint for unnamed_font.unnamed_glyph[7][0][1]>,
...
<RBPoint for unnamed_font.unnamed_glyph[7][0][4]>]

]]></python>

<p>
Let's have a look at these different attributes. In the end, they're all describing the same shape, the same actual points. It's just sorted in different ways for different purposes.

<ul>

<li>
<strong>contour.points:</strong> This is a list of all points on a contour. off-curve and on-curve points are presented as <strong>RPoint</strong>objects. Each RPoint has x, y, type and smooth attributes. On-cuve and off-curve points are treated as equals.
</li>

<li>
<strong>contour.segments:</strong> A segment is an object which represents a series of off-curve points and finally one on-curve point. Though kind of abstract, segments are needed to deal with quadratic curves which can have several off-curves on a row.
</li>

<li>
<strong>contour.bPoints:</strong> bPoints are objects which look more or less like the curve points you know from editing Beziers. One main on-curve point and two satellite off-curve points or <strong>bcps</strong>: an incoming one and an outgoing one. This is more or less the kind of point that was used in <strong>RoboFog</strong> code.
</li>


</ul>


</p>

<p>

Again, please refer to the <a href="http://letterror.com/code/robofab/howto/understandcontours.html" target="docs"  class="reference">Understanding Contours and Segments</a> to make sense of these things visually.
</p>

<p>
Finally, when you iterate through the contour.points, you get to see <a href="http://letterror.com/code/robofab/objects/point.html" target="new" class="reference">RPoint</a> objects with familiar things like x, y, and type attributes.
</p>

<pythonsource src="examples/iteratePoints.py"/>

<python type="output"><![CDATA[37 509 move
37 407 offcurve
119 325 offcurve
221 325 curve
323 325 offcurve
405 407 offcurve
405 509 curve
405 611 offcurve
323 693 offcurve
221 693 curve
119 693 offcurve
37 611 offcurve
37 509 curve
]]></python>

<p>
That looks interesting! Finally we're dealing with the stuff that letters are made of. You can now find the coordinates of every single point in the font, and change them if you want. But it looks very cumbersome to actually add shapes like this, all these contour objects, point objects. That's going to hurt, no? Yes. So, if you want to draw new forms there is a solution.
</p>

<h2>The Pen and Draw model</h2>
 
 
<p>
The pen/draw model is a very powerful concept, but it might seem a bit abstract to begin with. If you're interested in building filters, shape manipulating scripts, or programmatically draw glyphs, this is good to study. Otherwise, if you're here for the first time, just remember that there are ways to get paths into glyphs and that this is where you saw the examples for later reference.
</p>

<p>
	Glyph objects have a 
	<strong>
		draw() 
	</strong>
	method which takes a 
	<strong>
		Pen 
	</strong>
	object as a parameter. All glyphs know how to draw and all pen objects have the same methods (see below). When draw() is called, the glyph instructs the pen to recreate the shapes using <strong>moveTo()</strong>, <strong>lineTo()</strong>, <strong>curveTo()</strong> commands. The pen/draw() model is a standardised way of getting to the point data in a glyph. It is also a standardised way of getting data into a glyph. The glyph doesn't have to know what the pen is doing with its information and the pen doesn't have to know where the glyph gets its data from. That's how we like things in the object oriented world. 
</p>
	
	
<p>
There is a wide range of pen objects available for different things. Some pens just print the coordinates of a glyph. Some pens draw contours in a glyph, some manipulate the data, others can draw on screen under certain conditions. 
</p>
	

<p>
How to get a pen object? A bunch of them are stored in the <strong>robofab/pens</strong> module, have a look in the source! But one of the first things you'll want to use a pen for is to construct paths in a glyph. A Glyph object has a <strong>glyph.getPen()</strong> method which will return the right Pen object for drawing in that glyph. Example:
</p>


	<pythonsource src="examples/drawStuffWithPen.py"/>

	

<python type="output"><![CDATA[<robofab.pens.adapterPens.SegmentToPointPen instance at 0x65d2558>]]></python>


<p>
The next example will show the use of a Pen object which doesn't construct any path, but rather it  prints the instructions the glyph is calling to draw itself. Note: the stuff printed out by <strong>PrintingSegmentPen</strong> is python code too. You can use this snippet to convert a shape into python code, if for whatever reason you want to draw stuff programmatically. That's how the previous example was created: draw a shape in a glyph, print the draw instructions, write the rest of the code.
</p>



	<pythonsource src="examples/printingPen.py"/>


<python type="output"><![CDATA[pen.moveTo((37, 509))
pen.curveTo((37, 407), (119, 325), (221, 325))
pen.curveTo((323, 325), (405, 407), (405, 509))
pen.curveTo((405, 611), (323, 693), (221, 693))
pen.curveTo((119, 693), (37, 611), (37, 509))
pen.closePath()]]></python>



<p>
The following example uses a Pen to draw boxes as a simple rasteriser.  Perhaps a bit overboard, but it illustrates what you can do with Pens and creating paths in RoboFab.
</p>

	<pythonsource src="examples/sillyRasteriser.py"/>


<p>

<img src="talks/rasteriser.gif" alt="rasteriser" width="400" height="193" />
<br/>
This is what it looks like.
</p>

<p>

	
	A more in-depth discussion of the Pen protocol at the <a href="http://just.letterror.com/ltrwiki/PenProtocol" class="reference" target="docs">LettError wiki</a>. More examples of using pens, and some samples using pens to filter letterforms in the <a href="http://letterror.com/code/robofab/howto/usepens.html" class="reference" target="new">RoboFab docs</a>. 
	
</p>

<h2>Another kind of pen</h2>

<p>
Well, it wouldn't be Python if there weren't at least two ways of doing things. The pen/draw() model draws on-curve points and only accepts off-curves as part of the curveTo() and qCurveTo() methods, there's no room for additional information. For instance a <strong>smooth</strong> flag or a name for a point (and there are good reasons to want to do that). That's where <strong>glyph.drawPoints()</strong> comes in handy. This method is similar to <strong>glyph.draw()</strong> but it takes a different pen, a <strong>PointPen</strong>. All points are drawn one by one. PointPens are useful when you want to exactly address all information of each point in a shape. Compare the output of this example with the previous one. It's the same shape. Chances are you won't need pointPens for some time, but if you start working with pens it is good to know they exist.
</p>


<python><![CDATA[# use a point pen

from robofab.world import CurrentFont
from robofab.pens.pointPen import PrintingPointPen

font = CurrentFont()
glyph = font['A']
pen = PrintingPointPen()
glyph.drawPoints(pen)]]></python>

<python type="output"><![CDATA[pen.beginPath()
pen.addPoint((37, 509), segmentType='curve', smooth=True)
pen.addPoint((37, 407), **{'selected': False})
pen.addPoint((119, 325), **{'selected': False})
pen.addPoint((221, 325), segmentType='curve', smooth=True, **{'selected': 0})
pen.addPoint((323, 325), **{'selected': False})
pen.addPoint((405, 407), **{'selected': False})
pen.addPoint((405, 509), segmentType='curve', smooth=True, **{'selected': 0})
pen.addPoint((405, 611), **{'selected': False})
pen.addPoint((323, 693), **{'selected': False})
pen.addPoint((221, 693), segmentType='curve', smooth=True, **{'selected': 0})
pen.addPoint((119, 693), **{'selected': False})
pen.addPoint((37, 611), **{'selected': False})
pen.endPath()]]></python>

<p>
Notice that a pointPen only has 3 methods: <strong>addPoint</strong>, <strong>beginPath</strong>  and <strong>endPath</strong>.
</p>


<h2>Path manipulation</h2>
<p>
FontLab has path manipulation tools which let you remove overlap and add and subtract shapes. Remove overlap is available: <strong>glyph.removeOverlap()</strong>. Here is an example using the FontLab layer to subtract one shape from another to produce a third.
</p>

	<pythonsource src="examples/cookieCutter.py"/>

<p>
This example also sneakily introduces the <strong>naked()</strong> method of the glyph object. This method returns FontLab's own object for the glyph. We'll look at this in a bit more detail later on.
</p>



</xml>