<?xml version="1.0" encoding="iso-8859-1"?>
<xml>
	<include src="settings/generic.xml" />
	<synopsis
		name="RFont"
		description="contains Glyphs, names, kerning, data"
		keywords="objects, font, glyph, info, kerning" />
	<title>RoboFab Objects: RFont</title> 

<div id="titlepic">
	<img src="img/offdrawmodel_07.gif" alt="" border="0"/>
</div>

	<div class="content">
		<h1>RFont()</h1>
		
		
		<h3>Usage</h3> <pre>#Usage examples
# start using the current font
f = CurrentFont()

# get a clean, empty new font object,
# appropriate for the current environment
f = robofab.world.RFont()

# get an open dialog and start a new font
f = OpenFont()

# open the font at path
f = OpenFont(path)
    </pre>
    <h3>Description</h3> 
		<p>
			Perhaps the first object you get to play with. The RFont object is the central part that connects all glyphs with font information (like names, key dimensions etc.). In FontLab the RFont object talks directly to the glyphs and font data in the FontLab font it belongs to. In UFO or NoneLab use, the RFont object contains the data and saves it to UFO. RFont object behave like dictionaries: the glyphname is the key and the returned value is a <a href="objects/glyph.html">RGlyph</a> object for that glyph. If the glyph does not exist RFont will raise an IndexError.
RFont has a couple of important sub-objects which are worth checking out. The font's kerning is stored in a <a href="objects/kerning.html">RKerning</a> object and can be reached as an attribute at <strong>RFont.kerning</strong>. Fontnames, key dimensions, flags etc are stored in a <a href="objects/info.html">RInfo</a> object which is available through <strong>RFont.info</strong>. The RFont.lib is an <strong>RLib</strong> object which behaves as a dictionary. 
		</p>
    <h3>Iterating</h3> 
		<p>
One of the most important uses of the RFont object is that it makes it really easy to iterate ("step through") the glyphs in the font.
<pre>
f = CurrentFont()
for glyph in f:
	print glyph.name
&gt;&gt;&gt;a
&gt;&gt;&gt;b
&gt;&gt;&gt;c
etc..
</pre>
This makes the code clear and simple.
		</p>
		<h3>FontLab / UFO</h3> 
		<p>
			All basic attributes, methods and behaviour for RFont objects made in FontLab or in NoneLab are identical. However, the RFont objects in FontLab have some additional attributes and methods that make special FontLab functionality available. These extra methods and attributes are listed seperately below. 
		</p>
		<h3>RFont Attributes</h3> 
		<ul>
			<li>
				<strong>path</strong>: the path to the font. (read only)
			</li>
			<li>
				<strong>kerning</strong>: the <a href="objects/kerning.html">RKerning</a> object.
			</li>
			<li>
				<strong>info</strong>: the <a href="objects/info.html">RInfo</a> object with all the font's names and key dimensions.
			</li>
			<li>
				<strong>lib</strong>: the <a href="objects/lib.html">lib</a> object which behaves like a dictionary for arbitrary data that needs to be stored with the font. In FontLab the lib is stored in the .vfb file. In UFO based fonts the lib is a seperate .plist file. Have a look at <a href="howto/usethelib.html">how to use the lib</a>
			</li>
		</ul>
		<h3>Attribute examples</h3> <pre># Most useful attributes of RFont are
# actually stored in <a href="objects/info.html">RFont.info</a>
f = CurrentFont()
print f.info.unitsPerEm
&gt;&gt;&gt; 2048

# len() gives you the "length" of the font, i.e. the number of glyphs
print len(f)
&gt;&gt;&gt; 1120

# treat a font object as a dictionary to get to the glyphs
print f["A"]
&gt;&gt;&gt; &lt; Glyph for MyFont.A &gt;
</pre> <h3>RFont Methods available in FontLab and UFO</h3> 
		<p>
		</p>
		<ul>
			<li>
				<strong>RFont[glyphName]</strong>: asking the font for a glyph by glyphName like a dictionary.
			</li>
			<li>
				<strong>has_key(glyphName)</strong>: return True if glyphName is present in the font.
			</li>
			<li>
				<strong>keys()</strong>: return a list of all glyphnames in this font.
			</li>
			<li>
				<strong>newGlyph(glyphName, clear=True)</strong>: create a new, <strong>empty</strong> glyph in the font with glyphName. If clear is True (by default) this will clear the glyph if it already exists under this name.
			</li>
			<li>
				<strong>removeGlyph(glyphName)</strong>: remove a glyph from the font. This method will show a slightly different behaviour in FontLab and pure Python. In FontLab, components that reference the glyph that is being removed will be decomposed. In plain Python, the components will continue to point to the glyph.</li>
			<li><strong>insertGlyph(aGlyph)</strong> inserts aGlyph in the font. The new glyph is returned. If the font already has a glyph with the same name the exisiting data is deleted.</li>
			<li>
				<strong>compileGlyph(glyphName, baseName, accentNames, adjustWidth=False, preflight=False, printErrors=True)</strong>: Compile components into a new glyph using components and anchorpoints. <strong>glyphName</strong>: the name of the glyph where it all needs to go. <strong>baseName</strong>: the name of the base glyph. <strong>accentNames</strong>: a list of accentName, anchorName tuples, [('acute', 'top'), etc] 
			</li>
			<li>
				<strong>generateGlyph(glyphName, replace=True, preflight=False, printErrors=True)</strong>: Generate a glyph and return it. Assembled from GlyphConstruction.txt. <strong>replace</strong> is True the font will replace the glyph if there is already one with this name. <strong>preflight</strong> is True: the font will attempt to generate the glyph without adding it to the font. Do this to find out if there are any problems to make this glyph. For instance missing glyphs or components could be a problem. See <a href="howto/buildingaccents.html">building accents</a>.
			</li>
			<li>
				<strong>save(destDir=None, doProgress=False, saveNow=False)</strong>: Save the font.
			</li>
			<li>
				<strong>autoUnicodes()</strong>: Using fontTools.agl, assign Unicode lists to all glyphs in the font
			</li>
			<li>
				<strong>interpolate()</strong>: see <a href="howto/interpolate.html">how to interpolate</a> for a detailed description of the interpolate method in RFont.
			</li>
			<li>
				<strong>round()</strong>: round all of the coordinates in all of the glyphs to whole integer numbers. For instance a point at (12.3, -10.99) becomes (12, -11). UFO based fonts can deal with floating point coordinates, but for use in FontLab everything needs to be rounded otherwise bad things happen.
			</li>
			<li>
				<strong>update()</strong>: call to FontLab to refresh the font. You call update() after doing lots of manipulating and editing. In UFO based RFont objects update() doesn't do anything, but it exists.
			</li>
			<li>
				<strong>copy()</strong>: returns a deep copy of the font, i.e. all glyphs and all associated data is duplicated.
			</li>
			<li>
				<strong>getCharacterMapping()</strong>: returns a dict of unicode values to glyph names.
			</li>
		</ul>
		<h3>RFont Methods available FontLab only</h3> 
		<ul>
		<li>
			<strong>naked()</strong>: return the wrapped fontlab font object itself. This can be useful if you want to set very specific values in the fontlab font that aren't wrapped or handled by RoboFab objects.
		</li>
		<li>
			<strong>close()</strong>: close the font object and the font window in FontLab.
		</li>
		<li>
			<strong>appendHGuide()</strong>: append a horizontal guide.
		</li>
		<li>
			<strong>appendVGuide()</strong>: append a vertical guide.
		</li>
		<li>
			<strong>clearHGuides()</strong>: clear all horizontal guides
		</li>
		<li>
			<strong>clearVGuides()</strong>: clear all vertical guides
		</li>
		<li>
			<strong>generate(outputType, path=None)</strong>: call FontLab to generate fonts with these parameters and location. Have a look at <a href="howto/generatefonts.html">generate fonts</a> for a more detailed description of this method and how to use it.
		</li>
	</ul>
		<h3>RFont Attributes available FontLab only</h3> 
		<li>
			<strong>selection</strong>: this attribute is a list of selected glyph names in the font window.
		</li>
	</ul>


<h3>Method examples</h3> <pre>
f = CurrentFont()

# the keys() method returns a list of glyphnames:
print f.keys()
&gt;&gt;&gt; ['A', 'B', 'space', 'adieresis.alt1']

# find unicodes for each glyph by using the postscript name:
f.autoUnicodes()
</pre>


</div>
</xml>
