<?xml version="1.0" encoding="iso-8859-1"?>
<xml>
	<include src="settings/generic.xml" />
	<synopsis
		name="RFont"
		description="contains Glyphs, names, kerning, data"
		keywords="objects, font, glyph, info, kerning" />
	<title>RoboFab Objects: RFont</title> 

<div id="titlepic">
	<img src="img/offdrawmodel_07.gif" alt="" border="0"/>
</div>

	<div class="content">
		<h1>RFont()</h1>
		
		
		<h3>Usage</h3> 
		
		<pythonsource src="examples/usageFont.py"/>


    <h3>Description</h3> 
		<p>
			Perhaps the first object you get to play with. The RFont object is the central part that connects all glyphs with font information (like names, key dimensions etc.). In FontLab the RFont object talks directly to the glyphs and font data in the FontLab font it belongs to. In UFO or NoneLab use, the RFont object contains the data and saves it to UFO. RFont object behave like dictionaries: the glyphname is the key and the returned value is a <a href="objects/glyph.html">RGlyph</a> object for that glyph. If the glyph does not exist RFont will raise an IndexError.
		</p>
		<p>
RFont has a couple of important sub-objects which are worth checking out. The font's kerning is stored in a <a href="objects/kerning.html">RKerning</a> object and can be reached as an attribute at <strong>RFont.kerning</strong>. Fontnames, key dimensions, flags etc are stored in a <a href="objects/info.html">RInfo</a> object which is available through <strong>RFont.info</strong>. The RFont.lib is an <strong>RLib</strong> object which behaves as a dictionary. 
		</p>
    <h3>Iterating</h3> 
		<p>
One of the most important uses of the RFont object is that it makes it really easy to iterate ("step through") the glyphs in the font.
		</p>

		<pythonsource src="examples/fontIterate.py"/>

<python type="output"><![CDATA[
a
b
c
..etc..
]]></python>

This makes the code clear and simple.

		<h3>FontLab / UFO</h3> 
		<p>
			All basic attributes, methods and behaviour for RFont objects created in FontLab or in NoneLab are identical. However, the RFont objects in FontLab have some additional attributes and methods that make special FontLab functionality available. These extra methods and attributes are listed seperately below. 
		</p>
		<h3>RFont Attributes</h3> 
		<ul>
			<li>
				<strong>path</strong>: the path to the font. (read only)
			</li>
			<li>
				<strong>kerning</strong>: the <a href="objects/kerning.html">RKerning</a> object. Cache the font.kerning object to optimise your script for speed:
				<python><![CDATA[# cache the kerning object for speed
from robofab.world import CurrentFont
f = CurrentFont()
cachedKerning = f.kerning
# continue to use cachedKerning, not f.kerning.
]]></python>

</li>
			<li>
				<strong>info</strong>: the <a href="objects/info.html">RInfo</a> object with all the font's names and key dimensions.
			</li>
			<li>
				<strong>lib</strong>: the <a href="objects/lib.html">lib</a> object which behaves like a dictionary for arbitrary data that needs to be stored with the font. In FontLab the lib is stored in the .vfb file. In UFO based fonts the lib is a seperate .plist file. Have a look at <a href="howto/usethelib.html">how to use the lib</a>
			</li>
			<li>
				<strong>fileName</strong>: the filename and path of this font.
			</li>
		</ul>
		<h3>Attribute examples</h3>
		
		<pythonsource src="examples/fontAttributes.py"/>


<python type="output"><![CDATA[
2048
<RKerning for MyFont>
glyphs in this font: 1120
<Glyph for MyFont.A>
]]></python>


 <h3>RFont Methods available in FontLab and UFO</h3> 
		<p>
		</p>
		<ul>
			<li>
				<strong>RFont[glyphName]</strong>: asking the font for a glyph by glyphName like a dictionary.
			</li>
			<li>
				<strong>has_key(glyphName)</strong>: return True if glyphName is present in the font.
			</li>
			<li>
				<strong>keys()</strong>: return a list of all glyphnames in this font.
			</li>
			<li>
				<strong>newGlyph(glyphName, clear=True)</strong>: create a new, <strong>empty</strong> glyph in the font with glyphName. If clear is True (by default) this will clear the glyph if it already exists under this name. Note: <strong>clear=True</strong> is now default in both FontLab and NoneLab implementations.
			</li>
			<li>
				<strong>removeGlyph(glyphName)</strong>: remove a glyph from the font. This method will show a slightly different behaviour in FontLab and pure Python. In FontLab, components that reference the glyph that is being removed will be decomposed. In plain Python, the components will continue to point to the glyph.</li>
			<li><strong>insertGlyph(aGlyph, as=None)</strong> inserts aGlyph in the font, the new glyph obejct is returned. If the font already has a glyph with the same name the exisiting data is deleted. The optional <strong>as</strong> parameter is an alternative glyph name, to be used if you want to insert the glyph with a different name.</li>
			<li>
				<strong>compileGlyph(glyphName, baseName, accentNames, adjustWidth=False, preflight=False, printErrors=True)</strong>: Compile components into a new glyph using components and anchorpoints. <strong>glyphName</strong>: the name of the glyph where it all needs to go. <strong>baseName</strong>: the name of the base glyph. <strong>accentNames</strong>: a list of accentName, anchorName tuples, [('acute', 'top'), etc] 
			</li>
			<li>
				<strong>generateGlyph(glyphName, replace=True, preflight=False, printErrors=True)</strong>: Generate a glyph and return it. Assembled from GlyphConstruction.txt. <strong>replace</strong> is True the font will replace the glyph if there is already one with this name. <strong>preflight</strong> is True: the font will attempt to generate the glyph without adding it to the font. Do this to find out if there are any problems to make this glyph. For instance missing glyphs or components could be a problem. See <a href="howto/buildingaccents.html">building accents</a>.
			</li>
			<li>
<strong>getReverseComponentMapping()</strong>: Get a reversed map of component references in the font.
		<python type="output"><![CDATA[
{
	'A' : ['Aacute', 'Aring']
	'acute' : ['Aacute']
	'ring' : ['Aring']
	#etc.
}
]]></python>
			</li>
			<li>
				<strong>save(destDir=None, doProgress=False, saveNow=False)</strong>: Save the font.
			</li>
			<li>
				<strong>autoUnicodes()</strong>: Using fontTools.agl, assign Unicode lists to all glyphs in the font
			</li>
			<li>
				<strong>interpolate()</strong>: see <a href="howto/interpolate.html">how to interpolate</a> for a detailed description of the interpolate method in RFont.
			</li>
			<li>
				<strong>round()</strong>: round all of the coordinates in all of the glyphs to whole integer numbers. For instance a point at (12.3, -10.99) becomes (12, -11). UFO based fonts can deal with floating point coordinates, but for use in FontLab everything needs to be rounded otherwise bad things happen.
			</li>
			<li>
				<strong>update()</strong>: call to FontLab to refresh the font. You call update() after doing lots of manipulating and editing. In UFO based RFont objects update() doesn't do anything, but it exists.
			</li>
			<li>
				<strong>copy()</strong>: returns a deep copy of the font, i.e. all glyphs and all associated data is duplicated.
			</li>
			<li>
				<strong>getCharacterMapping()</strong>: returns a dict of unicode values to glyph names.
			</li>
		</ul>



<h3>Method examples</h3> 


		<pythonsource src="examples/fontMethods.py"/>


<python type="output"><![CDATA[
['A', 'B', 'space', 'adieresis.alt1']
]]></python>


<h1>FontLab</h1>

<p>
The following attributes and methods are only available to RoboFab objects in FontLab as they're based on application specific features.
</p>

		<h2>RFont Methods only available in FontLab</h2> 
		<ul>
		<li>
			<strong>naked()</strong>: return the wrapped fontlab font object itself. This can be useful if you want to set very specific values in the fontlab font that aren't wrapped or handled by RoboFab objects.
		</li>
			<li>
				<strong>writeUFO((path=None, doProgress=False,
			glyphNameToFileNameFunc=None)</strong>: write the font to UFO at path. doProgress=True gives you a progressbar if you want. glyphNameToFileNameFunc is an optional callback for alternative naming schemes. <a href="howto/glifnames.html">See How to use glyph naming schemes</a>
			</li>
		<li>
			<strong>close()</strong>: close the font object and the font window in FontLab.
		</li>
		<li>
			<strong>appendHGuide()</strong>: append a horizontal guide.
		</li>
		<li>
			<strong>appendVGuide()</strong>: append a vertical guide.
		</li>
		<li>
			<strong>clearHGuides()</strong>: clear all horizontal guides
		</li>
		<li>
			<strong>clearVGuides()</strong>: clear all vertical guides
		</li>
		<li>
			<strong>generate(outputType, path=None)</strong>: call FontLab to generate fonts with these parameters and location. Have a look at <a href="howto/generatefonts.html">generate fonts</a> for a more detailed description of this method and how to use it.
		</li>
		</ul>
		<h3>RFont Attributes available in FontLab only</h3> 
		<ul>
		<li>
			<strong>selection</strong>: a list of selected glyph names in the font window.
		</li>
	</ul>

<h3>Attribute examples</h3> 

		<pythonsource src="examples/fontMethodsFL.py"/>

<python type="output"><![CDATA[
['A', 'B']
]]></python>

</div>
</xml>
