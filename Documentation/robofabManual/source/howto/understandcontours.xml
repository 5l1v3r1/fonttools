<?xml version="1.0" encoding="iso-8859-1"?>
<xml>
	<include src="settings/generic.xml" />
	<synopsis name="Understanding Contours" description="how contours, segments and points work." keywords="contour, point, segment, howto" />
	<title>How to Understand Contours</title> 
	<div class="content">
		<h1>Understanding Contours and Segments</h1> 
		<p>
			Now, this is an important part of RoboFab so pay attention. In the world of digital font formats we have several different kinds of ways of describing outlines. Bezier curves for PostScript fonts, Quadratic curves for TrueType fonts. Each with their own peculiarities. RoboFab is format agnostic so it should be able to store all postscript and all truetype points. The structure here is meant to be able to do all that. 
		</p>
		<p>
			Diagrams by Tal Leming. 
		</p>
		<h3>Contours</h3> 
		<p>
			A glyph can contain one or more contours. Depending on what you want to do, there are different ways of looking at the data of the contour, the points, the line segments. The RContour object is way to the outlines. A description of the <a href="objects/contour.html">RContour</a> object. 
		</p>
		<br />
		<img src="objects/contours.jpg" alt="contour" width="300" height="300" /> 
		<br />

<python><![CDATA[
# take a glyph (one with outlines obviously)
c = CurrentGlyph()
# get to contours by index:
print c[0]
]]></python>

<python type="output"><![CDATA[
< RContour for Mailer-Regular.a[0] >
15
# 15? 15 of what?
]]></python> 
		
		<h3>Segments</h3> 
		<p>
			This circle consists of a couple of segments, each a piece of of the contour. A contour is a sequence of segments, you can iterate through a contour to get segments. A contour also has methods for adding and deleting segments. 
			<br />
			<img src="objects/contours_segments.jpg" alt="segments" width="300" height="300" /> 
			<br />
		</p>

<python><![CDATA[
# segment code example
]]></python>

<p>
In turn, a segment is made up of a sequence of points. Any number of off-curve points followed by an on-curve point. For the PostScript-centric designers: in TrueType outlines it is allowed to have any number of off-curve points before an on-curve. These points know whether they need to be rendered as bezier of quadratic curves. A description of the <a href="objects/segment.html">RSegment</a> object. 
			<br />
			<img src="objects/contours_segments_points.jpg" alt="segments" width="300" height="300" /> 
			<br />
		</p>
		<h3>Points</h3> 
		<p>
			Another way to look at a contour is as a sequence of on-curve and off-curve points. This is the approach taken by glyph.drawPoints() and PointPen. A description of the <a href="objects/point.html">RPoint</a> object. 
		</p>
		<br />
		<img src="objects/contours_points.jpg" alt="segments" width="300" height="300" /> 
		<br />

<python><![CDATA[
# get straight to the points in a contour through the points attribute
g = CurrentGlyph()
for aPt in g[0].points:
]]></python>

<python type="output"><![CDATA[
< RPoint for Special-Bold.A[0][0] >
< RPoint for Special-Bold[1][1] >
	etc..
]]></python>
		
		<h3>bPoints</h3> 
		<p>
			This is another way to look at contours and its parts: bPoints behave very much like RoboFog points used to do. A point object has an incoming bcp, an on-curve ("anchor point" fog called it) and an outgoing bcp. This approach has been added for folks more at ease with the RoboFog structure. Note: if the contour contains series of off-curve points, bPoints won't help you. A description of the <a href="objects/bpoint.html">bPoint</a> object. 
		</p>
		<br />
		<img src="objects/contours_bpoints.jpg" alt="segments" width="300" height="300" /> 
		<br />
		

<python><![CDATA[
# bpoints
c = CurrentGlyph()
for aPt in c[0].bPoints:
	print aPt.anchor
	print aPt.bcpIn
	print aPt.bcpOut
	print aPt.type
]]></python>

<python type="output"><![CDATA[
...
etc..
]]></python>

	</div>
</xml>
