<?xml version="1.0" encoding="iso-8859-1"?>
<xml>
	<include src="settings/generic.xml" />
	<synopsis generate="1" name="Using Glyph Math" description="applying math operators on glyph objects." keywords="glyph, glyphmath" />
	<title>How to: Glyph Math</title> 
	<div class="content">
		<h1>Glyph Math</h1> 
		<p>
			RGlyph objects have methods that allow the objects to behave a bit like variables in simple math. These methods do not do additions or substractions of the surface area of the glyphs, like layering two glyphs on top of each other and than doing "remove overlap". Instead, they return new glyph objects in which each coordinate in each contour is the product of the two glyphs. 
		</p>
		<h2>Objects</h2> 
		<p>
			All glyph math operations in have new, orphaned, objects as result. For instance a substraction of two FontLab RoboFab glyphs will result in a new glyph object, but it won't be part of the font. If you want the result to be part of the font you have to add it explicitly, see the example at the bottom of this page. There are several reasons for this: 
		</p>
			<ul>
				<li>
					the result might not even come from glyphs in the same font, i.e. you can substract a glyph in one font from a glyph in another font. Where should the result live? you decide.
				</li>
				<li>
					You might not want the result to be part of your font when you're using it for further calculations. So: results from glyphmath operations are orphan glyphs that do not belong to any font.
				</li>
				<li>
					the results need to use floating point (19.234943) numbers for precision, FontLab only stores integer numbers (19)
				</li>
			</ul>
		<p>
			If you want to add a glyph (of any flavor, FontLab or UFO) to a font use the appendGlyph method: 
		</p>
		
		<python><![CDATA[
someNewGlyph = aFont.newGlyph("someNewGlyph")
someNewGlyph.appendGlyph(restultFromGlyphMath)

# note you have to set the width, appendGlyph does not automatically
# take the value.
someNewGlyph.width = restultFromGlyphMath.width
]]></python>

		<h2>Substraction</h2> 
		<p>
			Substraction returns a new glyph object with contours which represent the <strong>difference</strong> between the two previous glyphs. As a glyph itself, it's not much to look at. If you draw the result of a substraction it will probably look like a crumpled outline. 
		</p>
		<h3>Example Substraction</h3> 
		
		<python><![CDATA[		
f = CurrentFont()
g = f["a"]
h = f["b"]
# suppose g and h have compatible point structures
myRelativeGlyph = g - h
]]></python>
		
		<h2>Addition</h2> 
		<p>
			Addition returns a new glyph object with the contours which is the product of the two previous glyphs. If you just add two "normal" glyphs from a font (or multiple fonts for that matter) it will look odd. But you can also easily add a relative glyph (a result of substracting one glyph from another), which effectively means you're applying the difference between two glyphs to a third. And that can be a very useful action. 
		</p>
		<h3>Example Addition</h3> 
		
		<python><![CDATA[
# continue with myRelativeGlyph from the previous example
newglyph = f["x"] + myRelativeGlyph
]]></python>
		
		<h2>Multiplication</h2> 
		<p>
			When a normal glyph is multiplied it looks as if the glyph has been scaled. For instance multiplying a glyph with 0.5 scales the shapes 50%. 
		</p>
		<h3>Example Multiplication</h3> 
		
		<python><![CDATA[
# continue with myRelativeGlyph from the previous example
newglyph = f["x"] + 0.25 * myRelativeGlyph
]]></python>
		
		<h2>Division</h2> 
		<p>
			Divisions works just like multiplications, you just need to make sure not to divide by zero. 
		</p>
		<h3>Example Division</h3> 
		
		<python><![CDATA[
# continue with myRelativeGlyph from the previous example
newglyph = f["x"] + myRelativeGlyph / 4
]]></python>
		
		<h2>Combinations</h2> 
		<p>
			These examples are simple enough, but when you combine them the operations can become really powerful. You could recreate font interpolation using GlyphMath, or construct new networks of interpolations, additions, shifts, deltas that were impossible to build. 
		</p>
		<h3>All together now</h3> 
		<p>
			This is from the demo_GlyphMath.py which should be in the Scripts/RoboFabIntro folder. 
		</p>
		
		<pythonsource src="examples/gmathFun.py"/>

		<h2>Implementation limits</h2> 
		<p>
			In objectsFL (for use in FontLab), only RGlyph has glyphmath operators implemented. The result of a glyphmath operation in FontLab is <strong>always</strong> an object from objectsRF. In ObjectsRF most objects have *, + and - implemented. But considering the operators are mainly used for Glyph stuff, the RGlyph object is a bit more kitted out with division as well. 
		</p>
	</div>
</xml>
